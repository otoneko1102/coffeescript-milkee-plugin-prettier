// Generated by CoffeeScript 2.7.0
var PREFIX, c, collectCoffeeFiles, consola, fs, i, ignore, len, main, method, path, pkg, prettier, ref;

fs = require('fs');

path = require('path');

consola = require('consola');

prettier = require('prettier');

ignore = require('ignore');

pkg = require('../package.json');

PREFIX = `[${pkg.name}]`;

// Create a custom logger with prefix
c = {};

ref = ['log', 'info', 'success', 'warn', 'error', 'debug', 'start', 'box'];
for (i = 0, len = ref.length; i < len; i++) {
  method = ref[i];
  (function(method) {
    return c[method] = function(...args) {
      if (typeof args[0] === 'string') {
        args[0] = `${PREFIX} ${args[0]}`;
      }
      return consola[method](...args);
    };
  })(method);
}

// Helper: recursively collect .coffee files
collectCoffeeFiles = function(dir, list = []) {
  var ent, entries, error, full, j, len1;
  try {
    entries = fs.readdirSync(dir, {
      withFileTypes: true
    });
  } catch (error1) {
    error = error1;
    return list;
  }
  for (j = 0, len1 = entries.length; j < len1; j++) {
    ent = entries[j];
    full = path.join(dir, ent.name);
    if (ent.isDirectory()) {
      collectCoffeeFiles(full, list);
    } else if (path.extname(ent.name) === '.coffee') {
      list.push(full);
    }
  }
  return list;
};

// Export a plugin factory
main = function(opts = {}) {
  return async function(compilationResult) {
    var compiledFiles, config, defaultIgnore, err, error, file, files, formatted, formattedCount, ig, ignorePath, ignorePatterns, info, j, len1, outDir, output, pkgPath, prettierOptions, prettierrc, projectRoot, rcPath, ref1, rel, text;
    ({config, compiledFiles} = compilationResult);
    // Determine output directory
    output = (config != null ? config.output : void 0) || 'dist';
    outDir = (config != null ? (ref1 = config.options) != null ? ref1.join : void 0 : void 0) ? path.dirname(output) : output;
    projectRoot = process.cwd();
    // Handle prettierignore: can be a path (string) or an array of patterns
    ignorePath = null;
    ignorePatterns = null;
    ig = null;
    if (Array.isArray(opts != null ? opts.prettierignore : void 0)) {
      ignorePatterns = opts.prettierignore.filter(function(p) {
        return typeof p === 'string';
      });
      if (ignorePatterns.length > 0) {
        ig = ignore().add(ignorePatterns);
      }
    } else if (typeof (opts != null ? opts.prettierignore : void 0) === 'string') {
      ignorePath = path.isAbsolute(opts.prettierignore) ? opts.prettierignore : path.join(projectRoot, opts.prettierignore);
      if (!fs.existsSync(ignorePath)) {
        c.warn(`prettierignore not found at ${ignorePath}`);
        ignorePath = null;
      }
    } else {
      defaultIgnore = path.join(projectRoot, '.prettierignore');
      if (fs.existsSync(defaultIgnore)) {
        ignorePath = defaultIgnore;
      }
    }
    // Load prettierrc: opts.prettierrc can be an object or a path to a file. If not provided, try resolveConfig, then package.json
    prettierrc = null;
    if ((opts != null ? opts.prettierrc : void 0) != null) {
      if (typeof opts.prettierrc === 'object') {
        prettierrc = opts.prettierrc;
      } else if (typeof opts.prettierrc === 'string') {
        rcPath = path.isAbsolute(opts.prettierrc) ? opts.prettierrc : path.join(projectRoot, opts.prettierrc);
        try {
          prettierrc = JSON.parse(fs.readFileSync(rcPath, 'utf8'));
        } catch (error1) {
          error = error1;
          c.warn(`Failed to read prettierrc at ${rcPath}: ${error.message}`);
        }
      }
    }
    if (prettierrc == null) {
      try {
        prettierrc = (await prettier.resolveConfig(projectRoot));
      } catch (error1) {
        error = error1;
        prettierrc = null;
      }
    }
    if (prettierrc == null) {
      try {
        pkgPath = path.join(projectRoot, 'package.json');
        if (fs.existsSync(pkgPath)) {
          pkg = JSON.parse(fs.readFileSync(pkgPath, 'utf8'));
          if ((pkg != null ? pkg.prettier : void 0) != null) {
            prettierrc = pkg.prettier;
          }
        }
      } catch (error1) {
        error = error1;
      }
    }
    // ignore
    c.info(`Searching .coffee files in ${outDir}`);
    if (!fs.existsSync(outDir)) {
      c.warn(`Output directory not found: ${outDir}`);
      return;
    }
    files = collectCoffeeFiles(outDir);
    if (files.length === 0) {
      c.info(`No .coffee files found in ${outDir}`);
      return;
    }
    c.info(`Found ${files.length} .coffee file(s)`);
    formattedCount = 0;
    for (j = 0, len1 = files.length; j < len1; j++) {
      file = files[j];
      try {
        // Ensure we only format CoffeeScript files
        if (path.extname(file) !== '.coffee') {
          c.debug(`Skip non-coffee file: ${file}`);
          continue;
        }
        // Check ignore via patterns or ignore file
        if (ig != null) {
          rel = path.relative(projectRoot, file).split(path.sep).join('/');
          if (ig.ignores(rel)) {
            c.info(`Ignored by prettierignore patterns: ${file}`);
            continue;
          }
        } else if (ignorePath != null) {
          try {
            info = (await prettier.getFileInfo(file, {ignorePath}));
            if (info != null ? info.ignored : void 0) {
              c.info(`Ignored by .prettierignore: ${file}`);
              continue;
            }
          } catch (error1) {
            err = error1;
            c.debug(`Failed to check ignore for ${file}: ${err.message}`);
          }
        }
        text = fs.readFileSync(file, 'utf8');
        prettierOptions = Object.assign({}, prettierrc || {}, {
          filepath: file,
          plugins: [require.resolve('prettier-plugin-coffeescript')]
        });
        formatted = prettier.format(text, prettierOptions);
        if (formatted !== text) {
          fs.writeFileSync(file, formatted, 'utf8');
          formattedCount += 1;
          c.success(`Formatted: ${file}`);
        } else {
          c.debug(`Already formatted: ${file}`);
        }
      } catch (error1) {
        error = error1;
        c.error(`Failed to format ${file}: ${error.message}`);
      }
    }
    return c.success(`Prettier formatted ${formattedCount} file(s)`);
  };
};

module.exports = main;
